#include <cmath>
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <sstream>
#include <glut.h>

// Constants
const int OUTER_BOUNDARY_WIDTH = 10;
const int INNER_BOUNDARY_WIDTH = 20;
const int OBSTACLE_SIZE = 50;
const int POMEGRANATE_RADIUS = 15;
const int MIN_DISTANCE_FROM_BOUNDARY = 20;

struct Position {
    float x, y;
    float animationOffset;
};

struct Home {
    float x, y;
    bool isAvailable;
    float animationOffset;
};

Position powerUpPositions[2];
bool powerUpSpawned[2] = { false };
Position ObstaclePositions[6];
Position pomegranatePositions[9];
bool pomegranateSpawned[9] = { false };
Position playerPosition = { 0, 0 };
Home home = { glutGet(GLUT_SCREEN_WIDTH) - 100, OUTER_BOUNDARY_WIDTH + 100, false };
bool playerWins = false;
int remainingTime = 120;
bool gameover = false;
int score = 0;
int lives = 3;
float animationPhase = 0.0f;
float animationAmplitude = 5.0f; // You can adjust the amplitude of the animation here
bool speedMode = false; // Flag to indicate if player is in speed mode
float originalStep = 10.0f; // Original step value
float step = 20.0f;

void SeedRandomNumberGenerator() {
    srand(static_cast<unsigned int>(time(0)));
}

float CalculateDistance(float x1, float y1, float x2, float y2) {
    return std::sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
}

void ResetSpeed(int value) {
    speedMode = false; // Disable speed mode
    step = originalStep; // Reset step to the original value
}

void Timer(int value) {
    if (!gameover && remainingTime > 0) {
        remainingTime--;
        for (int i = 0; i < 2; ++i) {
            if (powerUpSpawned[i]) {
                float distance = CalculateDistance(playerPosition.x, playerPosition.y, powerUpPositions[i].x, powerUpPositions[i].y);
                if (distance < POMEGRANATE_RADIUS + 12) {
                    if (i == 1) { // Clock power-up collected
                        remainingTime += 10; // Add 10 seconds
                    }
                    else if (i == 0) { // Speed power-up collected
                        speedMode = true; // Enable speed mode
                        // Increase player speed by modifying the step value
                        step = 4.0; // Set step to a higher value (adjust this as needed)
                        // Schedule a timer callback to reset speed back to original value after 5 seconds
                        glutTimerFunc(5000, ResetSpeed, 0);
                    }
                    powerUpSpawned[i] = false; // Remove the power-up
                }
            }
        }
        glutPostRedisplay();
        glutTimerFunc(1000, Timer, 0);
    }
    else if (remainingTime <= 0) {
        gameover = true;
        glutPostRedisplay();
    }
}

void DisplayTimer(int screenWidth, int screenHeight) {
    std::ostringstream timerText;
    timerText << "Time: " << remainingTime << "s";
    std::string timerString = timerText.str();

    // Calculate text width for centering the text
    int textWidth = glutBitmapLength(GLUT_BITMAP_HELVETICA_18, reinterpret_cast<const unsigned char*>(timerString.c_str()));

    glColor3f(1.0f, 1.0f, 1.0f);
    glRasterPos2f((screenWidth - textWidth) / 2, screenHeight - 50); // Adjust the Y-coordinate as needed
    for (char c : timerString) {
        glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, c);
    }
}

void DisplayGameOverScreen(int screenWidth, int screenHeight) {
    glClearColor(1.0f, 0.0f, 0.0f, 1.0f); // Set clear color to red for game over screen
    glClear(GL_COLOR_BUFFER_BIT);

    std::string gameOverMessage = "Game Over!";
    int textWidth = gameOverMessage.length() * 9; // Assuming 9 pixels per character width
    int textX = (screenWidth - textWidth) / 2;
    int textY = screenHeight / 2;

    glColor3f(1.0f, 1.0f, 1.0f);
    glRasterPos2f(textX, textY);
    for (char c : gameOverMessage) {
        glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_24, c);
    }
}

void DisplayWinningScreen(int screenWidth, int screenHeight) {
    glClearColor(0.0f, 1.0f, 0.0f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);

    std::string gameOverMessage = "YOU WIN!";
    int textWidth = gameOverMessage.length() * 9; // Assuming 9 pixels per character width
    int textX = (screenWidth - textWidth) / 2;
    int textY = screenHeight / 2;

    glColor3f(1.0f, 1.0f, 1.0f);
    glRasterPos2f(textX, textY);
    for (char c : gameOverMessage) {
        glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_24, c);
    }
}

void DrawHome() {
    float yOffset = std::sin(glutGet(GLUT_ELAPSED_TIME) * 0.02f + home.animationOffset) * 20.0f;

    if (home.isAvailable) {
        // Draw a modern home
        glColor3f(0.8f, 0.6f, 0.2f); // Light Brown color for the home
        glBegin(GL_QUADS);
        glVertex2f(home.x, home.y + yOffset);
        glVertex2f(home.x + 50, home.y + yOffset);
        glVertex2f(home.x + 50, home.y + 70 + yOffset);
        glVertex2f(home.x, home.y + 70 + yOffset);
        glEnd();

        // Draw door
        glColor3f(0.3f, 0.3f, 0.3f); // Dark Gray color for the door
        glBegin(GL_QUADS);
        glVertex2f(home.x + 23, home.y + yOffset);
        glVertex2f(home.x + 27, home.y + yOffset);
        glVertex2f(home.x + 27, home.y + 35 + yOffset);
        glVertex2f(home.x + 23, home.y + 35 + yOffset);
        glEnd();

        // Draw windows
        glColor3f(0.3f, 0.7f, 0.9f); // Light Blue color for the windows
        glBegin(GL_QUADS);
        glVertex2f(home.x + 8, home.y + 40 + yOffset);
        glVertex2f(home.x + 18, home.y + 40 + yOffset);
        glVertex2f(home.x + 18, home.y + 55 + yOffset);
        glVertex2f(home.x + 8, home.y + 55 + yOffset);
        glEnd();

        glBegin(GL_QUADS);
        glVertex2f(home.x + 32, home.y + 40 + yOffset);
        glVertex2f(home.x + 42, home.y + 40 + yOffset);
        glVertex2f(home.x + 42, home.y + 55 + yOffset);
        glVertex2f(home.x + 32, home.y + 55 + yOffset);
        glEnd();

        glColor3f(0.5f, 0.2f, 0.0f); // Dark Brown color for the attic
        glBegin(GL_TRIANGLES);
        glVertex2f(home.x - 5, home.y + 70 + yOffset);
        glVertex2f(home.x + 55, home.y + 70 + yOffset);
        glVertex2f(home.x + 25, home.y + 100 + yOffset); // Apex of the roof
        glEnd();
    }
    else {
        // Draw a modern home
        glColor3f(0.8f, 0.6f, 0.2f); // Light Brown color for the home
        glBegin(GL_QUADS);
        glVertex2f(home.x, home.y + yOffset);
        glVertex2f(home.x + 50, home.y + yOffset);
        glVertex2f(home.x + 50, home.y + 70 + yOffset);
        glVertex2f(home.x, home.y + 70 + yOffset);
        glEnd();

        // Draw door
        glColor3f(0.3f, 0.3f, 0.3f); // Dark Gray color for the door
        glBegin(GL_QUADS);
        glVertex2f(home.x + 23, home.y + yOffset);
        glVertex2f(home.x + 27, home.y + yOffset);
        glVertex2f(home.x + 27, home.y + 35 + yOffset);
        glVertex2f(home.x + 23, home.y + 35 + yOffset);
        glEnd();

        // Draw windows
        glColor3f(0.3f, 0.7f, 0.9f); // Light Blue color for the windows
        glBegin(GL_QUADS);
        glVertex2f(home.x + 8, home.y + 40 + yOffset);
        glVertex2f(home.x + 18, home.y + 40 + yOffset);
        glVertex2f(home.x + 18, home.y + 55 + yOffset);
        glVertex2f(home.x + 8, home.y + 55 + yOffset);
        glEnd();

        glBegin(GL_QUADS);
        glVertex2f(home.x + 32, home.y + 40 + yOffset);
        glVertex2f(home.x + 42, home.y + 40 + yOffset);
        glVertex2f(home.x + 42, home.y + 55 + yOffset);
        glVertex2f(home.x + 32, home.y + 55 + yOffset);
        glEnd();

        glColor3f(0.5f, 0.2f, 0.0f); // Dark Brown color for the attic
        glBegin(GL_TRIANGLES);
        glVertex2f(home.x - 5, home.y + 70 + yOffset);
        glVertex2f(home.x + 55, home.y + 70 + yOffset);
        glVertex2f(home.x + 25, home.y + 100 + yOffset); // Apex of the roof
        glEnd();

        // Draw X on the home
        glColor3f(1.0f, 0.0f, 0.0f); // Red color for X
        glLineWidth(2);
        glBegin(GL_LINES);
        glVertex2f(home.x, home.y + yOffset);
        glVertex2f(home.x + 50, home.y + 70 + yOffset);
        glVertex2f(home.x, home.y + 70 + yOffset);
        glVertex2f(home.x + 50, home.y + yOffset);
        glEnd();
    }
}

void DrawScore() {
    std::ostringstream scoreText;
    scoreText << "Score: " << score;
    std::string scoreString = scoreText.str();

    glColor3f(1.0f, 1.0f, 1.0f);
    glRasterPos2f(30, glutGet(GLUT_SCREEN_HEIGHT) - 50); // Adjust the Y-coordinate as needed
    for (char c : scoreString) {
        glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, c);
    }
}

void DrawLives() {
    std::ostringstream livesText;
    livesText << "Lives left: " << lives;
    std::string livesString = livesText.str();

    glColor3f(1.0f, 1.0f, 1.0f);
    glRasterPos2f(glutGet(GLUT_SCREEN_WIDTH) - 150, glutGet(GLUT_SCREEN_HEIGHT) - 50); // Adjust position as needed
    for (char c : livesString) {
        glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, c);
    }
}

Position GenerateRandomPosition(int screenWidth, int screenHeight) {
    Position position;
    do {
        position.x = static_cast<float>(OUTER_BOUNDARY_WIDTH + rand() % (screenWidth - OUTER_BOUNDARY_WIDTH * 2));
        position.y = static_cast<float>(OUTER_BOUNDARY_WIDTH + rand() % (screenHeight - OUTER_BOUNDARY_WIDTH * 2));
    } while (position.x >= INNER_BOUNDARY_WIDTH &&
        position.x <= screenWidth - INNER_BOUNDARY_WIDTH &&
        position.y >= INNER_BOUNDARY_WIDTH &&
        position.y <= screenHeight - INNER_BOUNDARY_WIDTH &&
        (position.x < INNER_BOUNDARY_WIDTH + MIN_DISTANCE_FROM_BOUNDARY ||
            position.x > screenWidth - INNER_BOUNDARY_WIDTH - MIN_DISTANCE_FROM_BOUNDARY ||
            position.y < INNER_BOUNDARY_WIDTH + MIN_DISTANCE_FROM_BOUNDARY ||
            position.y > screenHeight - INNER_BOUNDARY_WIDTH - MIN_DISTANCE_FROM_BOUNDARY));

    // Check for collisions with obstacles
    for (int i = 0; i < 6; ++i) {
        if (std::abs(position.x - ObstaclePositions[i].x) < OBSTACLE_SIZE &&
            std::abs(position.y - ObstaclePositions[i].y) < OBSTACLE_SIZE) {
            return GenerateRandomPosition(screenWidth, screenHeight); // Recurse to generate a new position
        }
    }

    // Check for collisions with boundaries
    if (position.x < OUTER_BOUNDARY_WIDTH + MIN_DISTANCE_FROM_BOUNDARY ||
        position.x > screenWidth - OUTER_BOUNDARY_WIDTH - MIN_DISTANCE_FROM_BOUNDARY ||
        position.y < OUTER_BOUNDARY_WIDTH + MIN_DISTANCE_FROM_BOUNDARY ||
        position.y > screenHeight - OUTER_BOUNDARY_WIDTH - MIN_DISTANCE_FROM_BOUNDARY) {
        return GenerateRandomPosition(screenWidth, screenHeight); // Recurse to generate a new position
    }

    return position;
}

void DrawBoundary(int screenWidth, int screenHeight) {
    glLineWidth(5);
    glColor3f(1.0f, 0.0f, 0.0f);
    glBegin(GL_LINE_LOOP);
    glVertex2f(OUTER_BOUNDARY_WIDTH, OUTER_BOUNDARY_WIDTH);
    glVertex2f(screenWidth - OUTER_BOUNDARY_WIDTH, OUTER_BOUNDARY_WIDTH);
    glVertex2f(screenWidth - OUTER_BOUNDARY_WIDTH, screenHeight - OUTER_BOUNDARY_WIDTH);
    glVertex2f(OUTER_BOUNDARY_WIDTH, screenHeight - OUTER_BOUNDARY_WIDTH);
    glEnd();
}

void DrawInnerBoundary(int screenWidth, int screenHeight) {
    glLineWidth(3);
    glColor3f(1.0f, 1.0f, 0.0f);
    glBegin(GL_LINE_LOOP);
    glVertex2f(INNER_BOUNDARY_WIDTH, INNER_BOUNDARY_WIDTH);
    glVertex2f(screenWidth - INNER_BOUNDARY_WIDTH, INNER_BOUNDARY_WIDTH);
    glVertex2f(screenWidth - INNER_BOUNDARY_WIDTH, screenHeight - INNER_BOUNDARY_WIDTH);
    glVertex2f(INNER_BOUNDARY_WIDTH, screenHeight - INNER_BOUNDARY_WIDTH);
    glEnd();
}

void DrawCircle(float x, float y, float radius) {
    int numSegments = 100;
    glBegin(GL_TRIANGLE_FAN);
    for (int i = 0; i <= numSegments; ++i) {
        float angle = 2.0f * 3.1415926f * float(i) / float(numSegments);
        float dx = radius * std::cos(angle);
        float dy = radius * std::sin(angle);
        glVertex2f(x + dx, y + dy);
    }
    glEnd();
}

void DrawPlayer(float x, float y) {
    glLineWidth(3);
    glColor3f(0.0f, 0.0f, 0.0f);
    glBegin(GL_LINES);
    glVertex2f(x - 15, y + 20); // Upper line
    glVertex2f(x + 15, y + 20);
    glVertex2f(x + 15, y + 20);
    glVertex2f(x, y - 30); // Body
    glVertex2f(x, y - 30);
    glVertex2f(x - 15, y + 20);
    glEnd();

    glColor3f(0.0f, 0.0f, 0.0f);
    DrawCircle(x, y, 12);

    glColor3f(1.0f, 1.0f, 1.0f);
    DrawCircle(x - 5, y + 5, 2); // Left eye
    DrawCircle(x + 5, y + 5, 2); // Right eye
}

void DrawObstacle(float x, float y, float size) {
    glBegin(GL_QUADS);
    glColor3f(1.0f, 0.0f, 0.0f);
    glVertex2f(x, y);
    glVertex2f(x + size, y);
    glVertex2f(x + size, y + size);
    glVertex2f(x, y + size);
    glEnd();

    glLineWidth(2);
    glColor3f(1.0f, 1.0f, 1.0f);
    glBegin(GL_LINES);
    glVertex2f(x, y);
    glVertex2f(x + size, y + size);
    glVertex2f(x + size, y);
    glVertex2f(x, y + size);
    glEnd();
}

void InitializeObstacles() {
    ObstaclePositions[0] = { 200.0f, 200.0f };
    ObstaclePositions[1] = { 300.0f, 400.0f };
    ObstaclePositions[2] = { 500.0f, 350.0f };
    ObstaclePositions[3] = { 700.0f, 350.0f };
    ObstaclePositions[4] = { 900.0f, 400.0f };
    ObstaclePositions[5] = { 1100.0f, 350.0f };
}

void DrawPomegranate(float x, float y, float radius) {
    int numSegments = 100;

    glColor3f(1.0f, 0.0f, 0.0f);
    glBegin(GL_TRIANGLE_FAN);
    glVertex2f(x, y);
    for (int i = 0; i <= numSegments; ++i) {
        float angle = 2.0f * 3.1415926f * float(i) / float(numSegments);
        float dx = radius * std::cos(angle);
        float dy = radius * std::sin(angle);
        glVertex2f(x + dx, y + dy);
    }
    glEnd();

    glColor3f(0.0f, 1.0f, 0.0f);
    glBegin(GL_TRIANGLES);
    glVertex2f(x - radius * 0.6f, y + radius * 1.2f);
    glVertex2f(x + radius * 0.6f, y + radius * 1.2f);
    glVertex2f(x, y + radius * 1.8f);
    glEnd();

    glColor3f(0.5f, 0.3f, 0.0f);
    glLineWidth(2);
    glBegin(GL_LINES);
    glVertex2f(x, y + radius * 1.8f);
    glVertex2f(x, y + radius * 2.2f);
    glEnd();
}

void InitializePomegranates() {
    for (int i = 0; i < 9; ++i) {
        pomegranatePositions[i] = GenerateRandomPosition(glutGet(GLUT_SCREEN_WIDTH), glutGet(GLUT_SCREEN_HEIGHT));
        pomegranatePositions[i].animationOffset = static_cast<float>(rand() % 100) / 100.0f; // Random offset between 0 and 1
        pomegranateSpawned[i] = true;
    }
}

void DrawPomegranates() {
    float animationSpeed = 0.02f;
    float animationAmplitude = 10.0f;

    bool allPomegranatesCollected = true; // Flag to track if all pomegranates are collected

    for (int i = 0; i < 9; ++i) {
        if (pomegranateSpawned[i]) {
            float yOffset = std::sin(glutGet(GLUT_ELAPSED_TIME) * animationSpeed + pomegranatePositions[i].animationOffset) * animationAmplitude;
            DrawPomegranate(pomegranatePositions[i].x, pomegranatePositions[i].y + yOffset, POMEGRANATE_RADIUS);
            float distance = CalculateDistance(playerPosition.x, playerPosition.y, pomegranatePositions[i].x, pomegranatePositions[i].y);
            if (distance < POMEGRANATE_RADIUS + 12) {
                score++;
                pomegranateSpawned[i] = false;

                // Check if all pomegranates are collected
                bool anyPomegranatesLeft = false;
                for (int j = 0; j < 9; ++j) {
                    if (pomegranateSpawned[j]) {
                        anyPomegranatesLeft = true;
                        break;
                    }
                }

                if (!anyPomegranatesLeft) {
                    home.isAvailable = true; // Set home as available if all pomegranates are collected
                }
            }
            else {
                allPomegranatesCollected = false; // Not all pomegranates are collected yet
            }
        }
    }

    // If all pomegranates are collected, set home as available
    if (allPomegranatesCollected) {
        home.isAvailable = true;
        playerWins = true;
    }
}

void DrawSpeedPowerUp(float x, float y, float radius) {
    // Calculate the animation offset using sine function
    float yOffset = sin(animationPhase) * animationAmplitude;

    // Draw a modern and fancy speed power-up
    glColor3f(0.0f, 1.0f, 0.0f); // Green color for speed power-up
    DrawCircle(x, y + yOffset, radius);

    // Draw a lightning bolt symbol for speed power-up
    glColor3f(1.0f, 1.0f, 1.0f); // White color for the lightning bolt
    glLineWidth(5);
    glBegin(GL_LINES);
    glVertex2f(x - radius * 0.6f, y + radius * 0.4f + yOffset);
    glVertex2f(x + radius * 0.6f, y + radius * 0.4f + yOffset);
    glVertex2f(x, y - radius * 0.4f + yOffset);
    glVertex2f(x, y + radius * 0.6f + yOffset);
    glEnd();
}

void DrawClockPowerUp(float x, float y, float radius) {
    // Calculate the animation offset using cosine function
    float yOffset = cos(animationPhase) * animationAmplitude;

    // Draw a modern and fancy clock power-up
    glColor3f(1.0f, 1.0f, 0.0f); // Yellow color for clock power-up
    DrawCircle(x, y + yOffset, radius);

    // Draw clock hands for clock power-up
    glColor3f(0.0f, 0.0f, 0.0f); // Black color for clock hands
    glLineWidth(8);
    glBegin(GL_LINES);
    glVertex2f(x, y + yOffset);
    glVertex2f(x + radius * 0.5f, y + radius * 0.5f + yOffset); // Hour hand
    glVertex2f(x, y + yOffset);
    glVertex2f(x - radius * 0.5f, y + radius * 0.5f + yOffset); // Minute hand
    glEnd();

    // Draw clock legs
    glLineWidth(6);
    glBegin(GL_LINES);
    glVertex2f(x - radius * 0.3f, y - radius * 0.4f + yOffset);
    glVertex2f(x - radius * 0.3f, y - radius * 0.6f + yOffset);
    glVertex2f(x + radius * 0.3f, y - radius * 0.4f + yOffset);
    glVertex2f(x + radius * 0.3f, y - radius * 0.6f + yOffset);
    glEnd();
}

void DrawPowerUps() {
    for (int i = 0; i < 2; i++) {
        if (powerUpSpawned[i]) {
            float yOffset = std::sin(glutGet(GLUT_ELAPSED_TIME) * 0.02f + powerUpPositions[i].animationOffset) * 10.0f;

            if (i == 0) {
                DrawSpeedPowerUp(powerUpPositions[i].x, powerUpPositions[i].y + yOffset, POMEGRANATE_RADIUS);
            }
            else {
                DrawClockPowerUp(powerUpPositions[i].x, powerUpPositions[i].y + yOffset, POMEGRANATE_RADIUS);
            }
        }
    }
}

void InitializePowerUps() {
    for (int i = 0; i < 2; i++) {
        Position newPos;
        do {
            newPos = GenerateRandomPosition(glutGet(GLUT_SCREEN_WIDTH), glutGet(GLUT_SCREEN_HEIGHT));
        } while (newPos.x > home.x && newPos.x < home.x + 50 &&
            newPos.y > home.y && newPos.y < home.y + 70);

        powerUpPositions[i] = newPos;
        powerUpPositions[i].animationOffset = static_cast<float>(rand() % 100) / 100.0f; // Random offset between 0 and 1
        powerUpSpawned[i] = true;
    }
}

void DrawCloud(float x, float y, float size) {
    glColor3f(1.0f, 1.0f, 1.0f);
    DrawCircle(x, y, size);
    DrawCircle(x + size * 0.7, y + size * 0.2, size * 0.6);
    DrawCircle(x + size * 1.4, y, size);
}

void DrawBackground(int screenWidth, int screenHeight) {
    glClearColor(0.529f, 0.808f, 0.922f, 1.0f); // Sky Blue
    glClear(GL_COLOR_BUFFER_BIT);
    DrawCloud(200, 500, 30);
    DrawCloud(600, 550, 40);
    DrawCloud(1000, 480, 35);
}

void SpecialKey(int key, int x, int y) {
    if (!gameover) {
        float tempX = playerPosition.x;
        float tempY = playerPosition.y;

        switch (key) {
        case GLUT_KEY_UP:
            tempY += originalStep;
            break;
        case GLUT_KEY_DOWN:
            tempY -= originalStep;
            break;
        case GLUT_KEY_LEFT:
            tempX -= originalStep;
            break;
        case GLUT_KEY_RIGHT:
            tempX += originalStep;
            break;
        }

        // Check for collisions with obstacles
        bool obstacleCollision = false;
        for (int i = 0; i < 6; ++i) {
            if (tempX - 12 < ObstaclePositions[i].x + OBSTACLE_SIZE &&
                tempX + 12 > ObstaclePositions[i].x &&
                tempY - 12 < ObstaclePositions[i].y + OBSTACLE_SIZE &&
                tempY + 12 > ObstaclePositions[i].y) {
                // Player collided with an obstacle
                obstacleCollision = true;
                break;
            }
        }

        for (int i = 0; i < 2; ++i) {
            if (powerUpSpawned[i]) {
                float distance = CalculateDistance(playerPosition.x, playerPosition.y, powerUpPositions[i].x, powerUpPositions[i].y);
                if (distance < POMEGRANATE_RADIUS + 12) {
                    if (i == 0) { // Speed power-up collected
                        // Implement logic to increase player speed here (for example, update the step value)
                        // You can set a flag indicating that the player is in "speed mode" and modify the step value accordingly.
                        // After 5 seconds, reset the speed back to the original value.
                        // Example: isSpeedPowerUpActive = true;
                    }
                    else if (i == 1) { // Clock power-up collected
                        remainingTime += 10; // Add 10 seconds
                    }
                    powerUpSpawned[i] = false; // Remove the power-up
                }
            }
        }

        // Check for collisions with boundaries
        bool boundaryCollision =
            tempX < OUTER_BOUNDARY_WIDTH + INNER_BOUNDARY_WIDTH ||
            tempX > glutGet(GLUT_SCREEN_WIDTH) - OUTER_BOUNDARY_WIDTH - INNER_BOUNDARY_WIDTH ||
            tempY < OUTER_BOUNDARY_WIDTH + INNER_BOUNDARY_WIDTH ||
            tempY > glutGet(GLUT_SCREEN_HEIGHT) - OUTER_BOUNDARY_WIDTH - INNER_BOUNDARY_WIDTH;

        if (obstacleCollision || boundaryCollision) {
            // Player collided with an obstacle or boundary, decrement lives
            lives--;
            if (lives <= 0) {
                gameover = true; // Set game over flag if no lives left
            }
        }
        else {
            // If no collision with obstacles or boundaries, update player position
            playerPosition.x = tempX;
            playerPosition.y = tempY;
        }

        // Check if the player reaches the home and the home is available
        if (playerPosition.x > home.x && playerPosition.x < home.x + 50 &&
            playerPosition.y > home.y && playerPosition.y < home.y + 50 &&
            home.isAvailable) {
            // Transition to the win screen (you need to implement the win screen logic)
            // For example, you can set a flag indicating the win condition and display a win screen in the Display function.
            gameover = true;
        }
    }

    glutPostRedisplay();
}

void Display() {
    static float cloud1X = 200;
    static float cloud2X = 600;
    static float cloud3X = 1000;

    int screenWidth = glutGet(GLUT_SCREEN_WIDTH);
    int screenHeight = glutGet(GLUT_SCREEN_HEIGHT);

    cloud1X += 0.1f;
    cloud2X += 0.1f;
    cloud3X += 0.1f;

    if (cloud1X > screenWidth) {
        cloud1X = -200;
    }
    if (cloud2X > screenWidth) {
        cloud2X = -200;
    }
    if (cloud3X > screenWidth) {
        cloud3X = -200;
    }

    for (int i = 0; i < 2; i++) {
        if (powerUpSpawned[i]) {
            powerUpPositions[i].animationOffset += 0.02f;
        }
    }

    DrawPowerUps();

    DrawBackground(screenWidth, screenHeight);
    DrawBoundary(screenWidth, screenHeight);
    DrawInnerBoundary(screenWidth, screenHeight);
    DrawPlayer(playerPosition.x, playerPosition.y);
    DisplayTimer(screenWidth, screenHeight);
    DrawScore();
    DrawLives();
    DrawHome();

    for (int i = 0; i < 9; ++i) {
        if (pomegranateSpawned[i]) {
            float distance = CalculateDistance(playerPosition.x, playerPosition.y, pomegranatePositions[i].x, pomegranatePositions[i].y);
            if (distance < POMEGRANATE_RADIUS + 12) {
                score++;
                pomegranateSpawned[i] = false;

                // Check if all pomegranates are collected
                bool anyPomegranatesLeft = false;
                for (int j = 0; j < 9; ++j) {
                    if (pomegranateSpawned[j]) {
                        anyPomegranatesLeft = true;
                        break;
                    }
                }

                if (!anyPomegranatesLeft && playerPosition.x > home.x && playerPosition.x < home.x + 50 &&
                    playerPosition.y > home.y && playerPosition.y < home.y + 70) {
                    // All pomegranates collected and player is inside the home
                    playerWins = true;
                }
            }
        }
    }

    for (int i = 0; i < 6; ++i) {
        float distance = CalculateDistance(playerPosition.x, playerPosition.y, ObstaclePositions[i].x + OBSTACLE_SIZE / 2, ObstaclePositions[i].y + OBSTACLE_SIZE / 2);
        if (distance < OBSTACLE_SIZE / 2 + 12) { // Player and obstacle collision detected
            lives--; // Decrement lives
            if (lives <= 0) {
                gameover = true; // Set game over flag if no lives left
            }
            else {
                // Reset player position if lives left
                playerPosition.x = glutGet(GLUT_SCREEN_WIDTH) / 2.0f;
                playerPosition.y = glutGet(GLUT_SCREEN_HEIGHT) / 2.0f;
            }
        }
    }

    if (gameover) {
        if (playerWins) {
            DisplayWinningScreen(screenWidth, screenHeight);
        }
        else {
            DisplayGameOverScreen(screenWidth, screenHeight);
        }
    }

    for (int i = 0; i < 6; ++i) {
        DrawObstacle(ObstaclePositions[i].x, ObstaclePositions[i].y, OBSTACLE_SIZE);
    }

    DrawCloud(cloud1X, 500, 30);
    DrawCloud(cloud2X, 550, 40);
    DrawCloud(cloud3X, 480, 35);

    DrawPomegranates();
    DrawPowerUps();

    glutSwapBuffers();
    glutPostRedisplay();
}

int main(int argc, char** argv) {
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);
    SeedRandomNumberGenerator();
    int screenWidth = glutGet(GLUT_SCREEN_WIDTH);
    int screenHeight = glutGet(GLUT_SCREEN_HEIGHT);
    glutInitWindowSize(screenWidth, screenHeight);
    glutCreateWindow("OpenGL - Modern Design");
    glutDisplayFunc(Display);
    glutSpecialFunc(SpecialKey);
    glOrtho(0.0, screenWidth, 0.0, screenHeight, -1.0, 1.0);

    playerPosition.x = screenWidth / 2.0f;
    playerPosition.y = screenHeight / 2.0f;

    InitializeObstacles();
    InitializePomegranates();
    InitializePowerUps();

    glutTimerFunc(1000, Timer, 0); // Set up the timer function to call every 1000 milliseconds (1 second)

    glutIdleFunc(Display);
    glutMainLoop();
    return 0;
}